//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 2 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 9 colors.
  struct color {
    /// Color `Blue`.
    static let blue = Rswift.ColorResource(bundle: R.hostingBundle, name: "Blue")
    /// Color `Green`.
    static let green = Rswift.ColorResource(bundle: R.hostingBundle, name: "Green")
    /// Color `Grey`.
    static let grey = Rswift.ColorResource(bundle: R.hostingBundle, name: "Grey")
    /// Color `LightGreen`.
    static let lightGreen = Rswift.ColorResource(bundle: R.hostingBundle, name: "LightGreen")
    /// Color `NoRed`.
    static let noRed = Rswift.ColorResource(bundle: R.hostingBundle, name: "NoRed")
    /// Color `Red`.
    static let red = Rswift.ColorResource(bundle: R.hostingBundle, name: "Red")
    /// Color `RoyalBlue`.
    static let royalBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "RoyalBlue")
    /// Color `SelectedSubscriptionPlan`.
    static let selectedSubscriptionPlan = Rswift.ColorResource(bundle: R.hostingBundle, name: "SelectedSubscriptionPlan")
    /// Color `YesGreen`.
    static let yesGreen = Rswift.ColorResource(bundle: R.hostingBundle, name: "YesGreen")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Blue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func blue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.blue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Green", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func green(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.green, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Grey", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func grey(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.grey, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "LightGreen", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func lightGreen(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.lightGreen, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "NoRed", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func noRed(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.noRed, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "Red", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func red(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.red, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "RoyalBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func royalBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.royalBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SelectedSubscriptionPlan", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func selectedSubscriptionPlan(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.selectedSubscriptionPlan, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "YesGreen", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func yesGreen(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.yesGreen, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "Blue", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func blue(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.blue.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "Green", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func green(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.green.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "Grey", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func grey(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.grey.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "LightGreen", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func lightGreen(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.lightGreen.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "NoRed", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func noRed(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.noRed.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "Red", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func red(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.red.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "RoyalBlue", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func royalBlue(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.royalBlue.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SelectedSubscriptionPlan", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func selectedSubscriptionPlan(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.selectedSubscriptionPlan.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "YesGreen", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func yesGreen(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.yesGreen.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.entitlements` struct is generated, and contains static references to 3 properties.
  struct entitlements {
    struct comAppleDeveloperApplesignin {
      static let `default` = infoPlistString(path: ["com.apple.developer.applesignin"], key: "Default") ?? "Default"

      fileprivate init() {}
    }

    struct comAppleSecurityApplicationGroups {
      fileprivate init() {}
    }

    struct keychainAccessGroups {
      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 2 images.
  struct image {
    /// Image `appLogo`.
    static let appLogo = Rswift.ImageResource(bundle: R.hostingBundle, name: "appLogo")
    /// Image `back`.
    static let back = Rswift.ImageResource(bundle: R.hostingBundle, name: "back")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "appLogo", bundle: ..., traitCollection: ...)`
    static func appLogo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.appLogo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "back", bundle: ..., traitCollection: ...)`
    static func back(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.back, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Main"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 2 nibs.
  struct nib {
    /// Nib `EmployeeCell`.
    static let employeeCell = _R.nib._EmployeeCell()
    /// Nib `ScaleBarView`.
    static let scaleBarView = _R.nib._ScaleBarView()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "EmployeeCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.employeeCell) instead")
    static func employeeCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.employeeCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ScaleBarView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.scaleBarView) instead")
    static func scaleBarView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.scaleBarView)
    }
    #endif

    static func employeeCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> EmployeeCell? {
      return R.nib.employeeCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? EmployeeCell
    }

    static func scaleBarView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.scaleBarView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 1 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `EmployeeCell`.
    static let employeeCell: Rswift.ReuseIdentifier<EmployeeCell> = Rswift.ReuseIdentifier(identifier: "EmployeeCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 2 localization tables.
  struct string {
    /// This `R.string.appBasicInfo` struct is generated, and contains static references to 0 localization keys.
    struct appBasicInfo {
      fileprivate init() {}
    }

    /// This `R.string.localizableMessage` struct is generated, and contains static references to 40 localization keys.
    struct localizableMessage {
      /// Value: %@ and %@ is not matched.
      static let password_not_matched = Rswift.StringResource(key: "password_not_matched", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: %@ years %@ days ago
      static let years_days_ago = Rswift.StringResource(key: "years_days_ago", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: %@ years %@ days in the future
      static let years_days_in_future = Rswift.StringResource(key: "years_days_in_future", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: %@ years ago
      static let years_ago = Rswift.StringResource(key: "years_ago", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: %@ years in the future 
      static let years_in_future = Rswift.StringResource(key: "years_in_future", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Allow
      static let allow = Rswift.StringResource(key: "allow", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Allow when in use
      static let allow_when_in_Use = Rswift.StringResource(key: "allow_when_in_ use", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Dismiss
      static let dismiss = Rswift.StringResource(key: "dismiss", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Do you want to logout?
      static let logout_msg = Rswift.StringResource(key: "logout_msg", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Empty %@
      static let empty_err_msg = Rswift.StringResource(key: "empty_err_msg", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: From date should be less than To date
      static let error_date_range_selection = Rswift.StringResource(key: "error_date_range_selection", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Invalid %@ format
      static let invalid_err_msg = Rswift.StringResource(key: "invalid_err_msg", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Invalid %@. %@
      static let invalid_with_reason_err_msg = Rswift.StringResource(key: "invalid_with_reason_err_msg", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Last Hour
      static let last_hour = Rswift.StringResource(key: "last_hour", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Make sure your device is connected to the internet.
      static let device_connected_with_internet_warning = Rswift.StringResource(key: "device_connected_with_internet_warning", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Minimum 8 characters at least 1 Alphabet, 1 Number and 1 Special Character
      static let invalid_password = Rswift.StringResource(key: "invalid_password", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: No
      static let no = Rswift.StringResource(key: "no", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: No Internet Connection
      static let no_internet_connection = Rswift.StringResource(key: "no_internet_connection", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: No further information is available at this time
      static let no_further_information_available = Rswift.StringResource(key: "no_further_information_available", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Not Allow
      static let not_allow = Rswift.StringResource(key: "not_allow", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Not Determined
      static let not_determined = Rswift.StringResource(key: "not_determined", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Null Response
      static let null_response = Rswift.StringResource(key: "null_response", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Null URL
      static let null_url = Rswift.StringResource(key: "null_url", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Null data in api response
      static let null_data_in_response = Rswift.StringResource(key: "null_data_in_response", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Please enter valid email & cannot be empty
      static let email_err = Rswift.StringResource(key: "email_err", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Please try again, for the same please goes into settings.
      static let setting_problem = Rswift.StringResource(key: "setting_problem", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Restricted
      static let restricted = Rswift.StringResource(key: "restricted", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Something went wrong
      static let something_went_wrong = Rswift.StringResource(key: "something_went_wrong", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Something went wrong !   Please Check your internet Connection or Try again later.
      static let connectivity_err = Rswift.StringResource(key: "connectivity_err", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: The request timed out.!
      static let timed_out = Rswift.StringResource(key: "timed_out", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: The server encountered an error handling this request. Support has been notified.
      static let server_err = Rswift.StringResource(key: "server_err", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: This Week
      static let this_week = Rswift.StringResource(key: "this_week", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Time
      static let time = Rswift.StringResource(key: "time", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Today
      static let today = Rswift.StringResource(key: "today", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Unexpected error: if this problem continues, please contact support
      static let unexpected_error = Rswift.StringResource(key: "unexpected_error", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Update interface title
      static let update_interface_title = Rswift.StringResource(key: "update_interface_title", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: We encountered a problem interpreting the response from the server. Support has been notified. Contact support for assistance if the problem continues.
      static let parse_error_message = Rswift.StringResource(key: "parse_error_message", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Yes
      static let yes = Rswift.StringResource(key: "yes", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: Yesterday
      static let yesterday = Rswift.StringResource(key: "yesterday", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)
      /// Value: You must be logged in to access this
      static let must_be_logged_in_to_access_this = Rswift.StringResource(key: "must_be_logged_in_to_access_this", tableName: "LocalizableMessage", bundle: R.hostingBundle, locales: [], comment: nil)

      /// Value: %@ and %@ is not matched.
      static func password_not_matched(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("password_not_matched", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "password_not_matched"
        }

        let format = NSLocalizedString("password_not_matched", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// Value: %@ years %@ days ago
      static func years_days_ago(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("years_days_ago", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "years_days_ago"
        }

        let format = NSLocalizedString("years_days_ago", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// Value: %@ years %@ days in the future
      static func years_days_in_future(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("years_days_in_future", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "years_days_in_future"
        }

        let format = NSLocalizedString("years_days_in_future", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// Value: %@ years ago
      static func years_ago(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("years_ago", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "years_ago"
        }

        let format = NSLocalizedString("years_ago", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: %@ years in the future 
      static func years_in_future(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("years_in_future", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "years_in_future"
        }

        let format = NSLocalizedString("years_in_future", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: Allow
      static func allow(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("allow", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "allow"
        }

        return NSLocalizedString("allow", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Allow when in use
      static func allow_when_in_Use(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("allow_when_in_ use", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "allow_when_in_ use"
        }

        return NSLocalizedString("allow_when_in_ use", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Dismiss
      static func dismiss(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dismiss", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "dismiss"
        }

        return NSLocalizedString("dismiss", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Do you want to logout?
      static func logout_msg(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("logout_msg", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "logout_msg"
        }

        return NSLocalizedString("logout_msg", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Empty %@
      static func empty_err_msg(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("empty_err_msg", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "empty_err_msg"
        }

        let format = NSLocalizedString("empty_err_msg", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: From date should be less than To date
      static func error_date_range_selection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("error_date_range_selection", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "error_date_range_selection"
        }

        return NSLocalizedString("error_date_range_selection", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Invalid %@ format
      static func invalid_err_msg(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("invalid_err_msg", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "invalid_err_msg"
        }

        let format = NSLocalizedString("invalid_err_msg", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// Value: Invalid %@. %@
      static func invalid_with_reason_err_msg(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("invalid_with_reason_err_msg", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "invalid_with_reason_err_msg"
        }

        let format = NSLocalizedString("invalid_with_reason_err_msg", tableName: "LocalizableMessage", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// Value: Last Hour
      static func last_hour(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("last_hour", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "last_hour"
        }

        return NSLocalizedString("last_hour", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Make sure your device is connected to the internet.
      static func device_connected_with_internet_warning(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("device_connected_with_internet_warning", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "device_connected_with_internet_warning"
        }

        return NSLocalizedString("device_connected_with_internet_warning", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Minimum 8 characters at least 1 Alphabet, 1 Number and 1 Special Character
      static func invalid_password(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("invalid_password", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "invalid_password"
        }

        return NSLocalizedString("invalid_password", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: No
      static func no(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("no", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "no"
        }

        return NSLocalizedString("no", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: No Internet Connection
      static func no_internet_connection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("no_internet_connection", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "no_internet_connection"
        }

        return NSLocalizedString("no_internet_connection", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: No further information is available at this time
      static func no_further_information_available(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("no_further_information_available", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "no_further_information_available"
        }

        return NSLocalizedString("no_further_information_available", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Not Allow
      static func not_allow(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("not_allow", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "not_allow"
        }

        return NSLocalizedString("not_allow", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Not Determined
      static func not_determined(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("not_determined", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "not_determined"
        }

        return NSLocalizedString("not_determined", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Null Response
      static func null_response(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("null_response", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "null_response"
        }

        return NSLocalizedString("null_response", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Null URL
      static func null_url(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("null_url", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "null_url"
        }

        return NSLocalizedString("null_url", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Null data in api response
      static func null_data_in_response(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("null_data_in_response", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "null_data_in_response"
        }

        return NSLocalizedString("null_data_in_response", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Please enter valid email & cannot be empty
      static func email_err(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("email_err", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "email_err"
        }

        return NSLocalizedString("email_err", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Please try again, for the same please goes into settings.
      static func setting_problem(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("setting_problem", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "setting_problem"
        }

        return NSLocalizedString("setting_problem", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Restricted
      static func restricted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("restricted", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "restricted"
        }

        return NSLocalizedString("restricted", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Something went wrong
      static func something_went_wrong(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("something_went_wrong", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "something_went_wrong"
        }

        return NSLocalizedString("something_went_wrong", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Something went wrong !   Please Check your internet Connection or Try again later.
      static func connectivity_err(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connectivity_err", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "connectivity_err"
        }

        return NSLocalizedString("connectivity_err", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: The request timed out.!
      static func timed_out(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("timed_out", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "timed_out"
        }

        return NSLocalizedString("timed_out", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: The server encountered an error handling this request. Support has been notified.
      static func server_err(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("server_err", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "server_err"
        }

        return NSLocalizedString("server_err", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: This Week
      static func this_week(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("this_week", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "this_week"
        }

        return NSLocalizedString("this_week", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Time
      static func time(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("time", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "time"
        }

        return NSLocalizedString("time", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Today
      static func today(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("today", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "today"
        }

        return NSLocalizedString("today", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Unexpected error: if this problem continues, please contact support
      static func unexpected_error(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("unexpected_error", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "unexpected_error"
        }

        return NSLocalizedString("unexpected_error", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Update interface title
      static func update_interface_title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("update_interface_title", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "update_interface_title"
        }

        return NSLocalizedString("update_interface_title", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: We encountered a problem interpreting the response from the server. Support has been notified. Contact support for assistance if the problem continues.
      static func parse_error_message(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("parse_error_message", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "parse_error_message"
        }

        return NSLocalizedString("parse_error_message", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Yes
      static func yes(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("yes", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "yes"
        }

        return NSLocalizedString("yes", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: Yesterday
      static func yesterday(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("yesterday", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "yesterday"
        }

        return NSLocalizedString("yesterday", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      /// Value: You must be logged in to access this
      static func must_be_logged_in_to_access_this(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("must_be_logged_in_to_access_this", tableName: "LocalizableMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LocalizableMessage", preferredLanguages: preferredLanguages) else {
          return "must_be_logged_in_to_access_this"
        }

        return NSLocalizedString("must_be_logged_in_to_access_this", tableName: "LocalizableMessage", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib {
    struct _EmployeeCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "EmployeeCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> EmployeeCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? EmployeeCell
      }

      fileprivate init() {}
    }

    struct _ScaleBarView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ScaleBarView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "appLogo", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'appLogo' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = RxLoginVC

      let bundle = R.hostingBundle
      let employeesVC = StoryboardViewControllerResource<EmployeesVC>(identifier: "EmployeesVC")
      let loginVC = StoryboardViewControllerResource<LoginVC>(identifier: "LoginVC")
      let name = "Main"
      let rxLoginVC = StoryboardViewControllerResource<RxLoginVC>(identifier: "RxLoginVC")

      func employeesVC(_: Void = ()) -> EmployeesVC? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: employeesVC)
      }

      func loginVC(_: Void = ()) -> LoginVC? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: loginVC)
      }

      func rxLoginVC(_: Void = ()) -> RxLoginVC? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: rxLoginVC)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "back2", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'back2' is used in storyboard 'Main', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "Grey", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'Grey' is used in storyboard 'Main', but couldn't be loaded.") }
        }
        if _R.storyboard.main().employeesVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'employeesVC' could not be loaded from storyboard 'Main' as 'EmployeesVC'.") }
        if _R.storyboard.main().loginVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'loginVC' could not be loaded from storyboard 'Main' as 'LoginVC'.") }
        if _R.storyboard.main().rxLoginVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'rxLoginVC' could not be loaded from storyboard 'Main' as 'RxLoginVC'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
